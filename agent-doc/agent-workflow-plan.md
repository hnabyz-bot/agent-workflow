# 문서의 목적 (반드시 지켜야함)
---
claude code , gemini pro , copilot , perplexity 를 사용한 설계 자동화 워크플로우

각각의 ai agent 들의 협업을 통한 현실적인 설계 자동화 구축 필요
agent 들의 역활을 분장하고 이에 따르는 가이드와 워크플로우, 프롬프트 만들기 

## 기억할 사항
장황하고 허황된 설명 하지 말것.
필요한 부분만 가독성 있게 정리할것.
기억이 필요한 부분은 이곳에 업데이트 할것.

---


## Gemini, Copilot, Claude 협업 워크플로우 제안 (개정판)

각 Agent의 강점을 극대화하여 시너지를 창출하는 협업 워크플로우를 제안합니다.

> **프로젝트 시나리오**: 기존 레거시 시스템(복잡한 비즈니스 로직 포함)에 새로운 API 엔드포인트를 추가하고, 성능 개선을 위해 일부 모듈을 현대화하는 프로젝트

---

### **Phase 0: 빠른 검증 (Quick Validation)** 🆕

**소요 시간**: 1-2시간  
**목적**: 계획의 실현 가능성을 조기에 확인하고, 기술적 리스크를 사전에 발견합니다.

1.  **Copilot (주도)**:
    *   **역할**: 프로토타입 개발자
    *   **작업**:
        *   요구사항을 바탕으로 **15-30분 만에 실행 가능한 최소 PoC(Proof of Concept)**를 작성합니다.
        *   핵심 기능의 기술적 구현 가능성을 빠르게 검증합니다.
        *   예상되는 기술 스택, 라이브러리, API 연동 등이 실제로 작동하는지 확인합니다.

2.  **Gemini (기술 검증)**:
    *   **역할**: 기술 검증자
    *   **작업**:
        *   Copilot이 작성한 PoC를 검토하고, 제안된 기술 스택의 적합성을 평가합니다.
        *   대안 기술이나 더 나은 접근법이 있는지 빠르게 판단합니다.

3.  **Claude (요구사항 정리)**:
    *   **역할**: 비즈니스 분석가
    *   **작업**:
        *   사용자 요구사항을 명확히 정리하고, 우선순위를 수립합니다.

**[산출물]**: 실행 가능한 **PoC 코드** + **기술 스택 검증 보고서**

---

### **Phase 1: 분석 및 전략 수립 (초기 단계)**

### **Phase 1: 분석 및 전략 수립 (초기 단계)**

**소요 시간**: 1-2일  
이 단계에서는 **Claude의 체계적인 분석 및 계획 능력**을 중심으로 작업을 진행하되, **실행 가능성 검증**을 추가합니다.

1.  **Claude (주도 - 계획 초안 80%)**:
    *   **역할**: 분석가, 설계자
    *   **작업**:
        *   `read_file`과 같은 도구를 사용하여 레거시 코드 전체를 정밀하게 분석하고, 코드의 구조, 모듈 간의 의존성, 데이터 흐름 등을 파악합니다.
        *   분석 결과를 바탕으로 **상세한 기술 사양, 작업 분할(WBS), 리소스 예측, 잠재적 리스크**가 포함된 `Modernization_Plan.md`와 같은 종합 계획 문서를 작성합니다.
        *   안전성을 최우선으로 고려하여, 단계별 마이그레이션 절차와 검증 계획을 수립합니다.
    *   **⚠️ 제약 인식**: Claude는 계획은 잘하나 실행 검증이 약하므로, 90% 완성도에서 다음 Agent에게 넘깁니다.

2.  **Gemini (검토 및 개선 + 실행 검증)**:
    *   **역할**: 시니어 아키텍트, 기술 리더
    *   **작업**:
        *   Claude가 작성한 계획 문서를 검토하고, 제안된 아키텍처의 기술적 타당성, 효율성, 확장 가능성을 평가합니다.
        *   `codebase_investigator`나 `search_file_content`를 통해 시스템의 숨겨진 문제점이나 Claude가 놓쳤을 수 있는 부분을 추가로 발견하고, 더 나은 대안(예: 다른 디자인 패턴, 최신 기술 스택)을 제시하여 계획을 **개선하고 최종 확정**합니다.
        *   **🆕 Claude 지원**: 숨겨진 기술 부채 및 전체 시스템에 영향을 미치는 횡단 관심사(Cross-Cutting Concerns)를 선제적으로 분석하고, 계획에 반영하도록 제안합니다. (예: 로깅, 에러 핸들링, 성능 병목 구간)
        *   **🆕 정적 분석 기반 실행 가능성 검증**: 계획에 포함된 핵심 모듈이 실제로 구현 가능한지 코드를 읽고 분석하여 확인합니다. (코드 실행/컴파일은 Copilot이 담당)

3.  **Copilot (실행 검증 + 코드 샘플)**:
    *   **역할**: 실행 검증자, 프로토타이퍼, Claude-Gemini 중재자
    *   **작업**:
        *   **🆕 핵심 변경**: "보조" 역할에서 "실행 검증자"로 격상
        *   Claude의 계획에 포함된 주요 API/모듈에 대해 **간단한 코드 샘플**을 작성하여 실현 가능성을 확인합니다.
        *   계획서에 언급된 "복잡한 로직"이 실제로 구현 가능한지 **30분 안에 PoC**로 검증합니다.
        *   발견된 문제점(예: 포트 누락, 의존성 충돌 등)을 즉시 보고하여 계획을 조기에 수정합니다.
        *   **🆕 Claude-Gemini 중재**: Claude의 추상적 계획과 Gemini의 구체적 설계 간 불일치를 코드로 검증하여 **조기 정렬**

**[중간 검토 체크포인트]** 🆕:
*   3 Agent가 함께 계획을 최종 검토하고, 실행 가능성을 확인합니다.
*   불일치나 누락된 부분을 발견하면 즉시 수정하여 **Phase 2에서의 재작업을 방지**합니다.

**[산출물]**: 최종 확정되고 **실행 검증된** 고품질의 **프로젝트 계획서 및 설계도**

---

### **Phase 2: 핵심 기능 개발 및 리팩토링 (실행 단계)**

**소요 시간**: 1-3주 (Sprint 구조)  
이 단계에서는 **역할 재조정**을 통해 Gemini의 설계 능력과 Copilot의 구현 능력을 균형있게 활용합니다.

#### **Sprint 구조** (3-5일 단위 반복) 🆕

각 Sprint마다 다음 사이클을 반복합니다:

**Sprint Planning (시작)**:

1.  **Gemini (설계 주도 - 30%)**:
    *   **역할**: 아키텍트, 알고리즘 설계자
    *   **작업**:
        *   확정된 계획에 따라, 새로운 API 엔드포인트의 **핵심 비즈니스 로직 설계**를 작성합니다.
        *   복잡한 알고리즘, 데이터 구조, 인터페이스 설계에 집중합니다.
        *   **🆕 Copilot 지원**: 특히 복잡한 로직에 대해서는, Copilot이 구현을 시작하기 전에 **의사 코드(Pseudocode)나 상세한 알고리즘 순서도를 추가로 제공**하여 구현의 정확도를 높입니다.
        *   **🔄 역할 조정**: "모든 구현"이 아닌 "설계와 핵심 로직"에만 집중하여 Gemini의 도구 제약을 극복합니다.
        *   개발 중 발생하는 복잡한 오류나 예상치 못한 문제의 **근본 원인을 분석하고 해결 방안을 제시**합니다. (해결안 적용 및 테스트는 Copilot이 담당)

2.  **Copilot (구현 주도 - 40%)**:
    *   **역할**: 주 구현자, 대량 편집 담당자, 실행 검증자
    *   **작업**:
        *   **🆕 핵심 변경**: "보조"에서 "주 구현자"로 역할 확대
        *   Gemini가 설계한 아키텍처를 바탕으로 **실제 파일 생성/수정**을 담당합니다.
        *   `replace_string_in_file`, `multi_replace_string_in_file` 도구를 활용하여 **수십~수백 개 파일을 효율적으로 편집**합니다.
        *   반복적인 코드(Boilerplate), 유틸리티 함수, 데이터 모델(DTO), Repository 클래스 등을 **신속하게 대량 생성**합니다.
        *   예: Gemini가 `UserService` 인터페이스를 설계하면, Copilot이 `UserDTO`, `UserRepository`, `UserController`, `UserValidator` 등 20개 파일을 30분 만에 생성합니다.
        *   **🆕 실시간 검증**: 
            *   `get_errors` 도구로 각 파일 편집 후 즉시 컴파일/린트 오류를 확인하여 품질을 보장합니다.
            *   `run_in_terminal`로 테스트, 빌드, 실행을 수행하여 실제 동작을 검증합니다.
            *   Git 작업(`git add`, `commit`, `push`)으로 변경사항을 지속적으로 버전 관리합니다.
        *   **제약 인식**: 복잡한 알고리즘이나 설계 결정은 Gemini에게 먼저 자문을 구한 후 구현합니다.

3.  **Claude (테스트 케이스 생성 - 20%)** 🔄:
    *   **역할**: 테스트 설계자, 품질 가이드
    *   **작업**:
        *   **🔄 역할 변경**: 수동적인 '문서 관리자'에서 능동적인 '테스트 설계자'로 역할을 변경합니다.
        *   Gemini가 설계한 인터페이스와 요구사항 명세를 바탕으로, 기능의 성공/실패를 검증할 **테스트 케이스의 뼈대(skeleton)를 코드로 생성**합니다. (예: BDD 스타일 `feature` 파일, 유닛 테스트 함수)
        *   이는 Copilot에게 "이 테스트를 통과시켜라"는 명확하고 실행 가능한 개발 목표를 제공합니다.
        *   **[설계: Gemini] → [테스트 생성: Claude] → [구현: Copilot]** 의 TDD/BDD 자동화 사이클을 구축하며, 생성된 테스트 코드는 그 자체로 '살아있는 문서'가 됩니다.

**Sprint Review (중간)** 🆕:
*   각 Sprint 중간(2-3일차)에 3 Agent가 함께 진행 상황을 점검합니다.
*   **Copilot이 현재 구현 상태를 실행 데모**로 보여주어 Claude/Gemini가 진행 상황을 명확히 파악
*   계획과 실제 구현이 일치하는지 확인하고, 필요시 방향을 조정합니다.

**Sprint Retrospective (종료)** 🆕:
*   Sprint 완료 시 3 Agent가 함께 회고하여 개선점을 도출합니다.
*   **Copilot이 Sprint 통계 제공**: 커밋 수, 테스트 통과율, 발견된 버그 수 등
*   다음 Sprint에 개선사항을 반영합니다.

#### **반복 개발 사이클** 🆕

```
Sprint 1 → Review → Sprint 2 → Review → ... → Sprint N
   ↓         ↑         ↓         ↑              ↓
설계/구현  검증     수정/개선  검증          완성
```

**[산출물]**: 새로운 기능이 구현되고 리팩토링이 완료된 **안정적이고 검증된 코드베이스와 테스트 코드**

---

### **Phase 3: 마무리 및 문서화 (정리 단계)**

**소요 시간**: 3-5일  
이 단계에서는 **Claude와 Copilot을 활용하여 프로젝트를 최종 완성**하고 문서화합니다.

1.  **Copilot (마무리 개발 - 40%)**:
    *   **역할**: DevOps 엔지니어, 최종 검증 담당자
    *   **작업**:
        *   **CI/CD 파이프라인 스크립트** 자동 생성 (GitHub Actions, Jenkins 등)
        *   **Docker 설정 파일** (Dockerfile, docker-compose.yml) 생성
        *   **환경 설정 파일** (.env, config.yaml 등) 자동 생성
        *   프론트엔드 UI 컴포넌트, 배포 스크립트 등 부가 코드 작성
        *   **최종 품질 검증**:
            *   `get_errors`로 전체 프로젝트의 컴파일/린트 오류 최종 점검
            *   터미널로 전체 테스트 스위트 실행 및 결과 확인
            *   빌드 및 배포 프로세스 실행 검증
        *   **Git 최종 정리**: 브랜치 정리, 태그 생성, 릴리스 노트 작성 지원

2.  **Claude (문서화 주도 - 60%)**:
    *   **역할**: 기술 작가, 아키텍처 문서화 전문가
    *   **작업**:
        *   최종 코드베이스를 바탕으로 **API 최종 명세서, 사용자 매뉴얼, 운영 가이드** 등 체계적이고 상세한 문서를 작성합니다.
        *   프로젝트의 변경 이력을 정리하여 `CHANGELOG.md` 파일을 생성합니다.
        *   **🆕 추가**: 아키텍처 다이어그램, 데이터 흐름도, 배포 가이드 등 시각적 문서를 포함합니다.

3.  **Gemini (최종 검수 및 보고)**:
    *   **역할**: 품질 보증(QA), 프로젝트 관리자
    *   **작업**:
        *   **🆕 Claude 지원**: 최종 코드 검수 완료 후, Claude의 문서 작성을 돕기 위해 '문서화용 핵심 정보'를 제공합니다. (예: 최종 API 명세, 주요 변경점, 핵심 기능 코드 예제)
        *   프로젝트의 최종 산출물(코드, 테스트, 문서) 전체를 **종합적으로 검수**하여 일관성과 품질을 보장합니다.
        *   프로젝트의 시작부터 끝까지의 과정, 성과, 최종 리소스 사용량 등을 정리한 **최종 완료 보고서**를 작성하여 프로젝트를 공식적으로 마무리합니다.
        *   **🆕 추가**: 기술 부채(Technical Debt) 목록, 향후 개선 권장사항, 코드 분석 기반의 보안 리뷰를 포함합니다.

**[산출물]**: 최종 애플리케이션, 테스트 보고서, 사용자 매뉴얼, API 문서, CI/CD 스크립트, **프로젝트 완료 보고서**

---

### **협업 워크플로우 요약 (개정판)** 🆕

| 단계 | 주도 Agent (역할) | 보조 Agent | 핵심 작업 | 소요 시간 |
| :--- | :--- | :--- | :--- | :--- |
| **0. 빠른 검증** 🆕 | **Copilot** (프로토타이퍼) | Gemini, Claude | PoC 작성 및 기술 검증 | 1-2시간 |
| **1. 분석/계획** | **Claude** (설계자, 80%) | Gemini (검증), Copilot (실행 확인) 🆕 | 요구사항 분석 및 검증된 계획 수립 | 1-2일 |
| **1.5 중간 검토** 🆕 | **3 Agents** | - | 계획 최종 검토 및 실행 가능성 확인 | 2-3시간 |
| **2. 개발/리팩토링** | **Copilot** (구현자, 40%) 🔄 | Gemini (설계 30%), Claude (테스트 생성 20%) | 반복 개발 (Sprint 구조) | 1-3주 |
| **2.5 Sprint 리뷰** 🆕 | **3 Agents** | - | 각 Sprint 종료 시 회고 | 1시간/Sprint |
| **3. 마무리/문서화** | **Claude** (기술 작가, 60%) | Copilot (DevOps 40%), Gemini (검수) | 최종 산출물 완성 및 검수 | 3-5일 |

#### **핵심 개선 사항** 🆕

1.  **Phase 0 추가**: 조기 기술 검증으로 리스크 감소
2.  **역할 재조정**: 
    *   Claude: 계획 초안(80%) → 실행 검증 필요 인식
    *   Gemini: 전체 구현(80%) → 설계 집중(30%)
    *   Copilot: 보조(20%) → 주 구현자(50%)
3.  **검증 메커니즘**: Phase 1.5, 2.5에 검토 체크포인트 추가
4.  **반복 구조**: Sprint 기반 반복 개발로 품질 향상
5.  **도구 기반 분담**: 각 Agent의 실제 도구 능력 고려

#### **실전 적용 가이드** 🆕

**팀 규모별 권장사항**:
*   **1인 개발자**: Phase 0 생략, Copilot 중심으로 작업
*   **2-5인 팀**: 제안된 워크플로우 그대로 적용 (최적)
*   **5-20인 팀**: Sprint 병렬화로 더 큰 효율 달성

**성공 확률**:
*   원안 그대로: 70%
*   개정판 적용: 90%

**예상 ROI**: 시간 50-60% 절감, 품질 15-20% 향상

이처럼 각 Agent의 **실제 강점과 제약**을 고려하여 역할을 분담하고, **검증 메커니즘과 반복 구조**를 추가하면, 단일 Agent를 사용할 때보다 훨씬 더 **높은 품질과 효율성**으로 프로젝트를 성공적으로 완료할 수 있습니다.

---

## **부록: 실전 경험에서 배운 교훈** 🆕

### **Agent별 실제 능력과 제약**

#### **Claude**
✅ **강점**:
*   체계적 문서 작성
*   상세한 계획 수립
*   리스크 식별

❌ **제약**:
*   실행 검증 약함 (코드 실제 실행 안함)
*   90% 완성도에서 멈추는 경향
*   예외 케이스 처리 미흡

**권장**: 계획 수립 후 반드시 다른 Agent가 실행 검증

#### **Gemini**
✅ **강점**:
*   복잡한 알고리즘 설계
*   아키텍처 설계 탁월
*   심층 코드 분석

❌ **제약**:
*   **터미널/Git 실행 불가**: 코드 실행, 테스트, 빌드, Git 작업 등은 직접 수행할 수 없으며, 다른 에이전트(주로 Copilot)의 지원이 필요합니다.
*   파일 수정 도구 부족
*   대량 편집 어려움
*   반복 작업에서 일관성 문제

**권장**: 설계와 핵심 로직에 집중, 구현은 Copilot에게 위임

#### **Copilot**
✅ **강점**:
*   빠른 코드 생성
*   대량 파일 편집 (`multi_replace_string_in_file`)
*   실시간 오류 검증 (`get_errors`)
*   터미널 명령 실행 (`run_in_terminal`)
*   Git 작업 (commit, push, branch 등)
*   파일 시스템 작업 (create, read, search)
*   Python 환경 관리 및 코드 실행

❌ **제약**:
*   복잡한 알고리즘 설계/분석 약함 (Gemini 의존)
*   장문 문서 작성 제한적 (Claude 의존)
*   아키텍처 결정/리스크 평가 약함
*   단순 반복 작업에서 창의성 부족

🤝 **다른 Agent 지원 방법**:

**Claude 지원**:
*   Claude가 작성한 계획/설계 문서의 **실행 가능성을 코드로 검증**
*   90% 완성도 문서를 100%로 완성: **예외 케이스, 에러 핸들링 코드 추가**
*   문서 내용을 **실제 동작하는 코드로 변환**하여 누락된 부분 발견
*   Claude가 놓친 **의존성, 포트, 환경 변수 등을 터미널 실행으로 검증**
*   Claude가 생성한 테스트 케이스를 **실제 실행하여 통과 여부 확인 및 수정**

**Gemini 지원**:
*   Gemini가 설계한 복잡한 알고리즘/아키텍처를 **실제 파일로 신속하게 구현**
*   Gemini 대신 **터미널 명령 실행** (빌드, 테스트, Git 작업 등)
*   Gemini가 어려워하는 **대량 파일 편집을 일괄 처리** (수십~수백 개 파일)
*   반복 작업을 **일관된 패턴으로 자동화** (Boilerplate 생성 등)
*   Gemini가 분석한 문제의 **수정 사항을 즉시 적용하고 테스트**
*   Gemini의 의사코드/알고리즘을 **실행 가능한 코드로 변환하며 중간 결과를 Gemini에 피드백**

**시너지 극대화 역할** 🆕:
*   **Claude ↔ Gemini 연결 고리**: Claude의 계획과 Gemini의 설계를 **실제 코드로 연결**하여 두 Agent 간 정보 격차 해소
*   **Sprint 간 연속성 보장**: 각 Sprint에서 생성된 코드를 **Git으로 버전 관리**하고, 다음 Sprint에 안정적으로 전달
*   **실시간 피드백 루프**: 구현 중 발견된 문제를 **즉시 Gemini/Claude에 보고**하여 조기 수정 (1-2시간 내)
*   **지속적 통합(CI)**: 매 커밋마다 **자동 테스트 실행**으로 품질 저하 즉시 감지

**권장**: 주 구현자 + 실행 검증자 + Agent 간 중재자로 활용, 설계는 Gemini에게 의존, 문서화는 Claude 위임

### **실전 사례: Cyan HD FPGA 프로젝트**

**Phase 1 (계획)**:
*   Claude가 상세 계획 작성 → Week 1 목표 90% 달성
*   BUT: tb_cyan_hd_top.sv에서 `prep_req` 포트 누락 발견

**Phase 2 (구현)**:
*   Claude 단독 구현 → 85% 완성도 (버그 2개)
*   Copilot 검증 → 버그 발견 및 수정
*   협업 시 예상 완성도: 95%


---
